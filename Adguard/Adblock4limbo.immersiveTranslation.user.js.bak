// ==UserScript==
// @name         沉浸式翻译（Google Translate & 原文保护）
// @namespace    http://tampermonkey.net/
// @version      2025-12-08_Final_V22
// @description  纯静态版，将 Google 翻译加载成功判断的检查条件精确为是否有 ".skiptranslate.goog-te-gadget" 元素，等待 5 秒。
// @author       limbopro
// @match        https://*/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=johnnydecimal.com
// @grant        none
// ==/UserScript==

// --- I. 谷歌翻译加载与配置 ---

// 定义 localStorage key
const TRANSLATION_STATE_KEY = 'immersiveTranslationState';

/**
 * @function loadGoogleTranslateUI
 * @description 动态加载谷歌翻译组件，限制语言范围，并设置UI容器样式。
 */
function loadGoogleTranslateUI() {
    if (document.getElementById('google_translate_element')) return;

    // 1. 定义谷歌翻译初始化函数
    window.google = window.google || {};
    window.google.translate = window.translate || {};
    window.google.translate.TranslateElementInit = function () {
        new google.translate.TranslateElement({
            includedLanguages: 'zh-CN,en',
            layout: google.translate.TranslateElement.InlineLayout.SIMPLE,
            autoDisplay: false
        }, 'google_translate_element');
    };

    // 2. 创建并美化 UI 容器元素
    const uiContainerId = 'google_translate_element';
    let uiContainer = document.getElementById(uiContainerId);

    if (!uiContainer) {
        uiContainer = document.createElement('div');
        uiContainer.id = uiContainerId;
        document.body.appendChild(uiContainer);

        // 设置容器浮动样式和 notranslate 标记
        uiContainer.classList.add('notranslate');
        uiContainer.style.position = 'fixed';
        uiContainer.style.top = '40px';
        uiContainer.style.right = '0px';
        uiContainer.style.zIndex = '9999';
        uiContainer.style.backgroundColor = '#f8f8f8';
        uiContainer.style.padding = '8px 12px';
        uiContainer.style.borderRadius = '5px 0px 0px 5px';
        uiContainer.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
        uiContainer.style.border = '1px solid #ddd';
        uiContainer.style.transition = 'box-shadow 0.3s ease-in-out';
        uiContainer.style.lineHeight = '0'; // 优化内联布局
    }

    // 3. 动态加载谷歌翻译脚本
    const scriptUrl = '//translate.google.com/translate_a/element.js?cb=google.translate.TranslateElementInit';
    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = scriptUrl;
    document.head.appendChild(script);
}

// --- II. 原文保护与双语复制逻辑 ---

/**
 * @function applyNotranslateProtection
 * @description 核心函数。遍历DOM识别正文块级元素，创建带有 'notranslate' 类的副本作为原文，
 * 并标记原元素（'.thatcloned'）以防止重复复制。
 */
function applyNotranslateProtection() {
    (() => {
        const textBlocksToClone = new Set();
        // 排除：不可见、结构性或特定 UI 元素。
        const excludedAncestors = '#contentWrapper, div.echo, pre, script, style, noscript, nav, aside, footer, header'; 

        // 匹配：数字, 空白, 逗号, 点号, 斜杠, 冒号, 短横线 (用于排除日期/数据块)
        const pureDataRegex = /^[0-9\s,./:\-]+$/;

        // 1. TreeWalker 找出所有需要处理的真实文本节点
        const walker = document.createTreeWalker(
            document.body,
            NodeFilter.SHOW_TEXT,
            {
                acceptNode(node) {
                    const parent = node.parentElement;
                    const text = node.nodeValue?.trim();
                    
                    // 1. 过滤：空文本、纯数字（长度小于等于 2）、或在排除祖先元素内。
                    if (!text || text.length < 2 || (/^\d+$/.test(text) && text.length <= 2) || parent?.closest(excludedAncestors)) {
                        return NodeFilter.FILTER_REJECT;
                    }

                    // 2. 过滤：跳过已处理或静态保护的元素内部。
                    if (parent?.closest('.notranslate') || parent?.closest('.thatcloned')) {
                        return NodeFilter.FILTER_REJECT;
                    }

                    return NodeFilter.FILTER_ACCEPT;
                }
            }
        );

        let node;
        while (node = walker.nextNode()) {
            let currentElement = node.parentElement;
            
            // 优化：从当前文本节点的父元素开始向上寻找合适的块级容器
            while (currentElement && currentElement !== document.body) {
                // 如果向上寻找时遇到排除祖先元素，则停止
                if (currentElement.closest(excludedAncestors)) break; 

                // 优化：只检查元素是否为常见的块级标签
                const tagName = currentElement.tagName;
                const isBlockTag = /^(H[1-6]|P|DIV|LI|ARTICLE|SECTION|MAIN|UL|OL|BLOCKQUOTE|FIGURE|DETAILS)$/.test(tagName);

                if (isBlockTag) {
                    
                    // 检查 0: 排除复杂的 UI 容器（子元素过多）
                    if (['DIV', 'LI', 'ARTICLE'].includes(tagName) && currentElement.children.length > 4) { 
                        break; 
                    }
                    
                    // 检查 1 & 2: 跳过已处理或已标记的元素
                    if (currentElement.classList.contains('thatcloned') || currentElement.classList.contains('notranslate')) break;

                    // 检查 3: 过滤纯数据文本块
                    const fullText = currentElement.textContent.trim();
                    if (fullText.length >= 2 && !pureDataRegex.test(fullText)) {
                        textBlocksToClone.add(currentElement);
                    }
                    
                    // 复制逻辑执行完毕或检查完毕后，跳出 while 循环
                    break;
                } 
                
                currentElement = currentElement.parentElement;
            }
        }

        if (textBlocksToClone.size === 0) {
            console.log('%c [Immersive Translate] 没有发现符合要求的正文块级元素。', 'color:#fff;background:#e74c3c;padding:2px 4px;border-radius:4px;');
            return;
        }

        // 2. 复制并插入 'notranslate' 副本，并标记原始元素
        Array.from(textBlocksToClone).reverse().forEach(originalElement => {
            // 最终防御性检查
            if (originalElement.classList.contains('thatcloned') || originalElement.classList.contains('notranslate')) {
                return;
            }

            const clone = originalElement.cloneNode(true);
            clone.classList.add('notranslate');
            originalElement.parentNode.insertBefore(clone, originalElement);
            originalElement.classList.add('thatcloned');
        });

        // 3. 完成提示
        console.log(`%c [Immersive Translate] 成功处理 ${textBlocksToClone.size} 个正文块级元素。`,
            'color:#fff;background:#0d6efd;font-weight:bold;padding:2px 4px;border-radius:4px;font-size:12px;');
    })();
}

/**
 * @function protectPreTags
 * @description 预先为代码块、表格、按钮、输入元素和常见的元数据容器添加 'notranslate' 类。
 */
function protectPreTags() {
    // 保护范围：div.house, button, input, label, table, pre, td
    document.querySelectorAll('div.plyr__controls,video,iframe,#dh_buttonContainer,#dh_button,div.house,button,input,label,table,pre,td,#dh_button').forEach((element) => {
        element.classList.add('notranslate');
    });
}


// --- III. 谷歌翻译加载检查 (V22 优化) ---

/**
 * @function checkGoogleTranslateLoaded
 * @description 延迟检查谷歌翻译是否成功加载，即检查是否存在 ".skiptranslate.goog-te-gadget" 元素。
 */
function checkGoogleTranslateLoaded() {
    // ✨ 关键检查: 检查是否存在 Google Translate 语言选择器的主体元素
    const isLoaded = document.querySelector('.skiptranslate.goog-te-gadget');
    
    // 如果元素未能检测出，则弹出警告
    if (!isLoaded) {
        console.warn("[Immersive Translate] 警告：谷歌翻译脚本可能加载失败或被拦截。");
        alert(
            "⚠️ 谷歌翻译未能正常加载。\n\n" +
            "这可能是由于：\n" +
            "1. 您的网络限制无法访问 Google 翻译服务。\n" +
            "2. 某些广告或隐私扩展程序拦截了 Google 的翻译脚本。\n\n" +
            "请检查您的网络设置或尝试禁用相关扩展程序。"
        );
        // 清理状态，恢复按钮
        removeClonedElements(true); 
    } else {
        console.log("[Immersive Translate] 谷歌翻译加载成功，UI组件已识别 (.skiptranslate.goog-te-gadget)。");
    }
}


// --- IV. 流程控制与用户交互 ---

/**
 * @function removeClonedElements
 * @description 移除页面上所有已复制的（双语）元素，并清理标记，恢复到原始页面状态。
 * @param {boolean} silent - 如果为 true，则不打印恢复消息。
 */
function removeClonedElements(silent = false) {
    if (!silent) {
        console.log("[Immersive Translate] 正在恢复原始页面状态...");
    }

    // 1. 移除所有精确匹配的复制元素（即我们创建的副本）。
    document.querySelectorAll('.notranslate').forEach(element => {
        if (element.id === 'google_translate_element') {
            return;
        }

        const nextSibling = element.nextElementSibling;
        
        // 只有当这个 .notranslate 元素的下一个兄弟元素是我们标记的 .thatcloned 时，才删除它
        if (nextSibling && nextSibling.classList.contains('thatcloned')) {
            element.remove();
        }
    });

    // 2. 清理所有原始元素上的标记（移除 .thatcloned 类）
    document.querySelectorAll('.thatcloned').forEach(originalElement => {
        originalElement.classList.remove('thatcloned');
    });

    // 3. 移除谷歌翻译的iframe和痕迹
    const googleBar = document.querySelector('.goog-te-banner-frame');
    if (googleBar) {
        googleBar.remove();
    }

    // 4. 清理谷歌翻译的cookie
    document.cookie = 'googtrans=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
    document.cookie = 'googtrans=/; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';

    // 5. 清除 localStorage 状态
    localStorage.removeItem(TRANSLATION_STATE_KEY);

    // 6. 更新按钮状态，显示“译”
    const button = document.getElementById('translation-button');
    if (button) {
        button.textContent = '译'; 
        button.classList.remove('translated');
    }

    if (!silent) {
        console.log("[Immersive Translate] 页面已恢复为仅显示原文状态。");
    }
}


/**
 * @function initiateTranslationFlow
 * @description 按照预定顺序执行所有初始化和翻译保护函数。
 */
function initiateTranslationFlow(isAutoStart = false) {
    console.log("[Immersive Translate] 翻译流程开始...");

    // 步骤 1: 静态保护 UI 元素
    protectPreTags();
    // 步骤 2: 加载 Google 翻译 UI
    loadGoogleTranslateUI();
    // 步骤 3: 复制和标记原文块
    applyNotranslateProtection();
    
    // 步骤 4: 设置 5000ms 延迟检查谷歌翻译是否成功加载。
    setTimeout(checkGoogleTranslateLoaded, 5000);

    // 步骤 5: 如果是用户手动点击启动，则存储状态
    if (!isAutoStart) {
        localStorage.setItem(TRANSLATION_STATE_KEY, 'translated');
    }

    // 确保按钮显示正确状态 (仅在 DOM 元素存在时)
    const button = document.getElementById('translation-button');
    if (button) {
        button.textContent = '原';
        button.classList.add('translated');
    }

    console.log("[Immersive Translate] 翻译流程执行完毕。");
}


/**
 * @function createFloatingButton
 * @description 创建并配置右下角的浮动“译/原”按钮，作为用户触发点。
 */
function createFloatingButton() {
    // 检查点：如果按钮已存在，则立即退出
    if (document.getElementById('translation-button')) {
        return;
    }

    // 1. 预设 Google Translate cookie，目标为 /auto/zh-CN
    document.cookie = "googtrans=/auto/zh-CN; path=/";

    // 2. 注入 CSS 样式
    const css = `
        #translation-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 10000;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #4A90E2;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            line-height: 50px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            border: none;
            user-select: none;
        }
        #translation-button:hover { background-color: #357ABD; box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); transform: scale(1.05); }
        #translation-button:active { transform: scale(0.98); background-color: #285A90; }

        /* 翻译状态下的样式变化，提供视觉反馈 */
        #translation-button.translated {
            background-color: #E74C3C;
        }
    `;
    const style = document.createElement('style');
    style.textContent = css;
    document.head.appendChild(style);

    // 3. 创建 HTML DOM 结构
    const button = document.createElement('div');
    button.id = 'translation-button';
    button.textContent = '译';

    // 4. 添加点击事件监听器，实现状态切换逻辑
    button.addEventListener('click', () => {
        const isTranslated = document.querySelector('.thatcloned');

        if (isTranslated) {
            removeClonedElements();
        } else {
            initiateTranslationFlow(false);
        }
    });

    // 5. 将按钮添加到页面的 body 中
    document.body.appendChild(button);

    // 6. 自动启动逻辑
    const savedState = localStorage.getItem(TRANSLATION_STATE_KEY);
    if (savedState === 'translated') {
        initiateTranslationFlow(true);
    }
}


// --- V. 脚本入口点 ---
createFloatingButton();